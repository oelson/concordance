#!/usr/bin/env python3
#-*- coding: utf-8 -*-
# 
# "Bible Index" Python3 WebSocket server.
#
# Copyright 2013 Houillon Nelson <houillon.nelson@gmail.com>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
# MA 02110-1301, USA.

import json
import os
import signal
import sys

from BibleParser.XMLBibleParser import XMLBibleParser
from time import time, sleep
from WebSocketServer import WebSocketServer, WebSocketCode, WebSocketException
from xml.etree import ElementTree

# Nombre de versets à sélectionner autours d'une référence lors d'un
# élargissement
context_size = 5

def init(self):
    """
    Ajoute au thread un dictionnaire qui contiendra les différents parseurs.
    Si le client associé au thread demande N traductions différentes, le thread
    instanciera N parseurs différents.
    """
    self.bible_parsers = {}

def handle(self, data):
    """
    Récupère un message JSON de la connection WebSocket
    """
    data = json.loads(data)
    # token à renvoyer en l'état
    if "tok" not in data:
        self.error("no token given")
        return
    # traduction de la bible à utiliser pour la recherche
    if "tra" not in data or data["tra"] not in bible_translations:
        self.error("no or bad translation given")
        return
    # instancie un parseur si nécessaire
    if translation not in self.bible_parsers:
        bible_xml_content = get_bible_xml(translation)
        self.info("new parser for the translation '{}'".format(translation))
        self.bible_parsers[translation] = XMLBibleParser(
            # passe par une fonction de service pour ne pas recharger à chaque
            # fois les mêmes fichiers (les fichiers XML contenant les bibles
            # sont très lourds)
            bible_xml_content
        )
    parser = self.bible_parsers[translation]
    parser.clean()
    # le token permet de sélectionner le service approprié
    if data["tok"] == "search":
        resp = handleSearchRequest(parser, data)
        resp = json.dumps(resp)
        self.send(resp)
    elif data["tok"] == "context":
        resp = handleContextRequest(parser, data)
        resp = json.dumps(resp)
        self.send(resp)
    else:
        self.error('unknown token "{}"'.format(data["tok"]))

def handleContextRequest(parser, data):
    """
    Traite une requête de contexte.
    """
    # sélectionne la référence principale et son contexte
    parser.add_contextual_reference(data["ref"], context_size, context_size)
    # itère sur les versets correspondants
    references = {}
    for reference, verse in parser:
        if reference.book not in references:
            references[reference.book] = {}
        if reference.chapter_low not in references[reference.book]:
            references[reference.book][reference.chapter_low] = {}
        references[reference.book][reference.chapter_low][reference.verse_low] = verse
    response = {
        "res": references,
        "now": int(round(time() * 1000)),
        "tok": data["tok"]
    }
    return response

def handleSearchRequest(parser, data):
    """
    Traite une recherche par mots-clés.
    """
    # correspondance avec des mots-entiers
    if "bou" in data:
        parser.set_word_boundary(data["bou"])
    # sensibilité à la case
    if "cas" in data:
        parser.set_case_sensitivity(data["cas"])
    # sensibilité aux accents
    if "acc" in data:
        parser.set_accent_sensitivity(data["acc"])
    # ajoute les références
    for r in data["ref"]:
        parser.add_reference(r)
    # recherche tous les mots suivants
    if "all" in data:
        parser.add_mandatory_keywords(data["all"])
    # recherche au moins un des mots suivants
    if "one" in data:
        parser.add_one_of_keywords(data["one"])
    # évite tous les mots suivants
    if "non" in data:
        parser.add_none_of_keywords(data["non"])
    # expression exacte
    if "exp" in data:
        parser.add_exact_expression(data["exp"])
    # recherche un nombre compris dans un intervalle
    if "ran" in data:
        if "l" in data["ran"]:
            if "h" in data["ran"]:
                parser.add_number_in_range(
                    int(data["ran"]["l"]),
                    int(data["ran"]["h"])
                )
            else:
                parser.add_number_in_range(
                    int(data["ran"]["l"])
                )
    # préfixe les résultats par des tirets
    parser.enable_highlighting("_")
    # itère sur les références de verset correspondants
    verses = []
    for reference, verse in parser:
        verses.append({
            "ref": str(reference),
            "verse": verse
        })
    response = {
        "res": verses,
        "now": int(round(time() * 1000)),
        "tok": data["tok"]
    }
    return response

"""
Obtention de la liste des fichier XML disponnibles
"""
bible_translations  = []
bible_xml_directory = os.environ.get("BIBLE_XML_DIRECTORY")

if not bible_xml_directory:
    print("env variable 'BIBLE_XML_DIRECTORY' must be set", file=sys.stderr)
    sys.exit(1)

# Liste les traductions de la bible existantes à partir du disque
os.chdir(bible_xml_directory)
for files in os.listdir("."):
    if files.endswith(".xml"):
        bible_translations.append(files[:-4])

# Fichiers XML
bible_xml_files = {}

def get_bible_xml(translation):
    """
    Fonction de service permettant d'obtenir le contenu (code XML) d'une
    traduction de la bible.
    Chaque fichier XML ne sera lu qu'une seule fois au cours de l'exécution du
    script.
    """
    if translation not in bible_translations:
        # Vérifie que la traduction existe
        raise ValueError("translation '{}' is unavailable".format(translation))
    if translation not in bible_xml_files:
        # Ouvre le fichier en lecture
        xml_path = "{}/{}.xml".format(
            bible_xml_directory,
            translation
        )
        with open(xml_path, 'r') as xml_file:
            # Le contenu du fichier XML ne sera lu qu'une seule fois au cours
            # de l'exécution du script
            bible_xml_files[translation] = xml_file.read()
        server.info("new translation read '{}'".format(translation))
    return bible_xml_files[translation]

"""
Instancie le serveur websocket de la concordance
"""
server = WebSocketServer.server(
    addr="",
    host="localhost",
    port=8080,
    init=init,
    handle=handle,
    debug=WebSocketCode.WebSocketDebugLevel.PRINT_NOTHING
)

# Arrête le serveur en cas de réception de SIGINT(2) ou de SIGTERM(15)
def die(signum, frame):
    # Signale aux clients qu'ils doivent envoyer un message de déconnexion
    # propre
    for t in server.clients:
        t.setCloseStatus(WebSocketCode.CloseFrameStatusCode.GOING_AWAY)
    server.stop()

signal.signal(signal.SIGINT,  die)
signal.signal(signal.SIGTERM, die)

server.start()

while server.is_alive():
    signal.pause()
